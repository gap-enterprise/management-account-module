<?xml version="1.1" encoding="UTF-8" standalone="no"?>
<!--
Copyright (c) 2022 Surati

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to read
the Software only. Permissions is hereby NOT GRANTED to use, copy, modify,
merge, publish, distribute, sublicense, and/or sell copies of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
-->
<databaseChangeLog xmlns="http://www.liquibase.org/xml/ns/dbchangelog" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-4.6.xsd">
  <changeSet author="baudoliver7" id="001" context="base">
    <sql>
		CREATE TABLE ma_sub_bundle (
	        id bigserial PRIMARY KEY,
		    no integer NOT NULL,
		    fiscal_year smallint NOT NULL,
			creation_date TIMESTAMP WITHOUT TIME ZONE NOT NULL,
			author_id bigint NOT NULL,
	        title character varying(10) NOT NULL,
	        section character varying(10) NOT NULL,
			bundle character varying(10) NOT NULL,
		    bundle_split_warrant boolean NOT NULL,
	        CONSTRAINT ma_sub_bundle_author_id_fkey FOREIGN KEY (author_id) REFERENCES ad_user (id)
	          ON UPDATE CASCADE ON DELETE CASCADE,
	        CONSTRAINT ma_sub_bundle_bundle_fkey FOREIGN KEY (bundle) REFERENCES gtp_bundle (code)
	          ON UPDATE CASCADE ON DELETE CASCADE,
	        CONSTRAINT ma_sub_bundle_title_fkey FOREIGN KEY (title) REFERENCES gtp_title (code)
	          ON UPDATE CASCADE ON DELETE CASCADE,
	        CONSTRAINT ma_sub_bundle_section_fkey FOREIGN KEY (section) REFERENCES gtp_section (code)
	          ON UPDATE CASCADE ON DELETE CASCADE
	      );

		  CREATE TABLE ma_annual_warrant (
	        warrant_id bigint NOT NULL,
			fiscal_year smallint NOT NULL,
			no integer NOT NULL,
		    annual_amount_to_pay DOUBLE PRECISION NOT NULL,
			annual_amount_paid DOUBLE PRECISION NOT NULL,
			annual_amount_left DOUBLE PRECISION NOT NULL,
		    is_split BOOLEAN NOT NULL,
			sub_bundle_id bigint,
		    CONSTRAINT ma_warrant_for_bundle_pkey PRIMARY KEY (warrant_id, fiscal_year),
	        CONSTRAINT ma_warrant_for_bundle_id_fkey FOREIGN KEY (warrant_id) REFERENCES gtp_warrant (id)
	          ON UPDATE CASCADE ON DELETE CASCADE,
	        CONSTRAINT ma_warrant_for_bundle_sub_bundle_id_fkey FOREIGN KEY (sub_bundle_id) REFERENCES ma_sub_bundle (id)
	          ON UPDATE CASCADE ON DELETE CASCADE
	      );

		CREATE VIEW ma_annual_warrant_view AS
			SELECT
				awr.no,
				awr.fiscal_year,
				awr.annual_amount_to_pay,
				awr.annual_amount_paid,
				awr.annual_amount_left,
				awr.sub_bundle_id,
		        NOT(wr.amount=awr.annual_amount_to_pay AND awr.annual_amount_left=0) AS is_split,
				wr.*
			FROM ma_annual_warrant awr
		    LEFT JOIN gtp_warrant_view wr ON wr.id = awr.warrant_id
			ORDER BY wr.id;

		<![CDATA[
		CREATE OR REPLACE FUNCTION ma_func_update_annual_warrant() RETURNS trigger AS
		'
		DECLARE
			cur_year smallint;
			cur_no integer;
			cur_is_split boolean;
			cur_warrant_id bigint;
			cur_total_amount double precision;
			cur_amount_paid_before double precision;
		    cur_annual_amount_to_pay double precision;
		    cur_annual_amount_paid double precision;
		    cur_annual_amount_left double precision;
		BEGIN
		    IF NEW.reference_document_id IS NULL THEN
		    	RETURN NEW;
		    END IF;
			cur_year := DATE_PART($$year$$, NEW.date);
			cur_warrant_id := NEW.reference_document_id;
		     SELECT SUM(amount) INTO cur_amount_paid_before
				FROM pay_payment_order
				WHERE reference_document_id=cur_warrant_id
				 AND status_id=$$EXECUTED$$
				 AND DATE_PART($$year$$, date) < cur_year
			    GROUP BY reference_document_id;
			 SELECT amount INTO cur_total_amount
			 FROM pay_reference_document WHERE id = cur_warrant_id;
		     cur_annual_amount_to_pay := COALESCE(cur_total_amount, 0) - COALESCE(cur_amount_paid_before, 0);
		     SELECT SUM(amount) INTO cur_annual_amount_paid
				FROM pay_payment_order
				WHERE reference_document_id=cur_warrant_id
				 AND status_id=$$EXECUTED$$
				 AND DATE_PART($$year$$, date) = cur_year
				GROUP BY reference_document_id;
			cur_annual_amount_paid := COALESCE(cur_annual_amount_paid, 0);
			cur_annual_amount_left := cur_annual_amount_to_pay - cur_annual_amount_paid;
			cur_is_split := NOT(cur_total_amount=cur_annual_amount_to_pay AND cur_annual_amount_left=0);
			cur_no := CASE
				WHEN (select count(*) from ma_annual_warrant where fiscal_year=cur_year and is_split=cur_is_split) = 0 THEN 1
				ELSE (select no from ma_annual_warrant where fiscal_year=cur_year and is_split=cur_is_split order by no desc limit 1) + 1
			END;
			IF EXISTS (
				SELECT * FROM ma_annual_warrant
				WHERE warrant_id = cur_warrant_id AND fiscal_year = cur_year
			) THEN
				UPDATE ma_annual_warrant
				SET annual_amount_to_pay=cur_annual_amount_to_pay,
					annual_amount_paid=cur_annual_amount_paid,
					annual_amount_left=cur_annual_amount_left,
					is_split=cur_is_split
				WHERE warrant_id = cur_warrant_id;
			ELSE
				INSERT INTO ma_annual_warrant(
					warrant_id, fiscal_year, annual_amount_to_pay,
					annual_amount_paid, annual_amount_left, is_split, no
				) VALUES (
					cur_warrant_id,
					cur_year,
					cur_annual_amount_to_pay,
					cur_annual_amount_paid,
					cur_annual_amount_left,
					cur_is_split,
					cur_no
				);
			END IF;
			DELETE FROM ma_annual_warrant
			WHERE warrant_id = cur_warrant_id
				AND fiscal_year = cur_year
				AND annual_amount_paid = 0
				AND sub_bundle_id IS NULL;
			RETURN NEW;
		END;
		'
		LANGUAGE plpgsql;
		]]>
		CREATE TRIGGER ma_tri_update_annual_warrant AFTER INSERT OR UPDATE OR DELETE ON pay_payment_order
			FOR EACH ROW EXECUTE FUNCTION ma_func_update_annual_warrant();
    </sql>
  </changeSet>
</databaseChangeLog>
